
0. Define Data Line
 - Use Syslog
Sep 16 10:36:26 jaejunh-mini rsyslogd: [origin software="rsyslogd" swVersion="5.8.6" x-pid="908" x-info="http://www.rsyslog.com"] rsyslogd was HUPed
Sep 16 10:36:26 jaejunh-mini rsyslogd: [origin software="rsyslogd" swVersion="5.8.6" x-pid="908" x-info="http://www.rsyslog.com"] rsyslogd was HUPed
Sep 16 10:36:26 jaejunh-mini anacron[23115]: Job `cron.daily' terminated (mailing output)
Sep 16 10:36:26 jaejunh-mini anacron[23115]: Can't find sendmail at /usr/sbin/sendmail, not mailing output
Sep 16 10:36:26 jaejunh-mini anacron[23115]: Normal exit (1 job run)
Sep 16 10:39:01 jaejunh-mini CRON[25505]: (root) CMD (  [ -x /usr/lib/php5/maxlifetime ] && [ -d /var/lib/php5 ] && find /var/lib/php5/ -depth -mindepth 1 -maxdepth 1 -type f -cmin +$(/usr/lib/php5/maxlifetime) ! -execdir fuser -s {} 2>/dev/null \; -delete)
Sep 17 09:56:12 jaejunh-mini NetworkManager[1021]: <info> (eth1): deactivating device (reason 'sleeping') [37]
Sep 17 09:56:13 jaejunh-mini NetworkManager[1021]: <info> (eth1): canceled DHCP transaction, DHCP client pid 11118
Sep 17 09:56:13 jaejunh-mini NetworkManager[1021]: <warn> DNS: plugin dnsmasq update failed
Sep 17 09:56:13 jaejunh-mini NetworkManager[1021]: <info> (eth1): removing resolv.conf from

- Analyze Syslog
Fixed Len    W String    W  String[Number(.Number)]          :  ComplexString  
------------  -----------  -------------------------            --------------
PrimaryTime, ServerName, ProgramName[process id],               LongMessage 
ptime	     server      program    pid                         ... 
	
			    ComplexString	
			   ----------------
			   < String   >?  ( String   )?                   Message		
			    ==========      ========                      ======== 
			   LogLevel,      LogOwner(Userid|location),      Message
			   level	  owner				  message 	                          

- Data Structure
  (Split and Match Syslog)

(def log-data-event 
	(new-event "LogDataEvent"
		{ "ptime" :string   ;; split -> 0 1 2 
		  "server" :string  ;;  -> 3
		  "program" : string ;; -> 4 split "[\[\]\:]"  -> 0
		  "pid"	:int         ;; -> 4 split -> 1	

		   ;; if (5 =~ /^\<[^\>]+\>/) { pop level } 
		   ;; if (5 =~ /^\([^\)]+\)/) { pop owner } 
		   ;; message = join(" ", rest)

		  "level" :string    ;; new string <- join " " rest 
		  "owner" :string    ;; new string 
		  "message" :string }))

 


====================================================================================================


1.  a. 특정 윈도우 타임 내에 동시 발현되는 Error의 위치를 리얼타임으로 카운팅하기.
 
       example:
  if, within any 20 second window, count 서버IP and 발생위치 from occurred ERROR


select server, program, level, "error pattern" as epattern, count(*) as "cnt"
from LogDataEvent.win:time(20 sec)
where match(epattern, message)
group by server, program, level
having level="error"

result:  error pattern에 대해서 
	어떤 서버에서 어느 프로그램에서 에러가 발생했는지 카운트 함. 


  특정 윈도우 타임 내에 동시 발현되는 error의 위치를 리얼타임으로 카운팅하기
select server, program, level, count(*) as 'cnt'
from LogDataEvent.win:time(20 sec)
where message like '%nm-dns-dnsmasq%'
group by server, program, level
having level='error'

2.  b. 굳이 신경쓰지 않아도 되는 메시지들의 제거.
 
  example:
          When 15 Warnings are received within any 5 second window, 
		but less than 5 include{$STRING} messages detected within 30 seconds,
          do nothing.

=>

	When 15 Warning win:time(5 sec)
	->
	When 5+ "string Message" win:time(30 sec) 
	
	==> 

	Catch All 15 Warnings


b1. select program, count(*) as cnt 
    from LogDataEvent.win:time(5)
    group by program, level 
    having level="warning", count(level) > 15

result:  
b2. select program, count(*) as cnt
    from LogDataEvent.win:time(30)
    group by program, level
    having level="warning", count(level) >= 5


select * from pattern [ every
	(e1=LogDataEvent(level='warning') ->
	 e2=LogDataEvent(e2.cnt > 5, match("string",message), e1.cnt 

	every e1 =

select windows(*).where(v => v.level ="warning" and v.....
]

select window(*), count(*) as cnt
from LogDataEvent.win:time(5)
group by program, level
having level="warning", count(level) > 15

select IP, Location // of 15 warnings
from ServerDataEvent.win:time(5 sec)
	.std:groupwin(Warning)
	.stat:uni(value, IP,Location) as s
where s.count > 3



select Module, count(*) 
from ServerDataEvent.win:time(5 sec)
group by Module
having Module="Warning" 

